<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" th:replace="~{layout :: layout('代理延迟历史', ~{::div})}">
<body>
    <div>
        <!-- 引入ECharts -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
        
        <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
            <h1 class="h2" th:text="${config.groupName + ' 代理延迟历史'}">代理延迟历史</h1>
            <div class="btn-toolbar mb-2 mb-md-0">
                <div class="btn-group me-2">
                    <button type="button" class="btn btn-sm btn-outline-secondary" onclick="loadChartData(7)">最近7天</button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" onclick="loadChartData(3)">最近3天</button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" onclick="loadChartData(1)">最近1天</button>
                </div>
                <a th:href="@{/proxy-monitor}" class="btn btn-sm btn-outline-primary">
                    <span data-feather="arrow-left"></span>
                    返回
                </a>
            </div>
        </div>

        <div class="row mb-4">
            <div class="col-md-12">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">代理组信息</h5>
                        <div class="row">
                            <div class="col-md-3">
                                <p><strong>代理组名称:</strong> <span th:text="${config.groupName}">Proxy</span></p>
                            </div>
                            <div class="col-md-3">
                                <p><strong>测试URL:</strong> <span th:text="${config.testUrl}">https://www.gstatic.com/generate_204</span></p>
                            </div>
                            <div class="col-md-3">
                                <p><strong>超时:</strong> <span th:text="${config.timeout}">5000</span>ms</p>
                            </div>
                            <div class="col-md-3">
                                <p><strong>状态:</strong> 
                                <span th:if="${config.enabled}" class="badge bg-success">已启用</span>
                                <span th:unless="${config.enabled}" class="badge bg-secondary">已禁用</span></p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 排序控制 -->
        <div class="row mb-4">
            <div class="col-md-12">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">排序方式</h5>
                        <div class="btn-group" role="group" aria-label="排序选项">
                            <button type="button" class="btn btn-outline-primary" onclick="sortProxies('connectivity', 'desc')">连通率高→低</button>
                            <button type="button" class="btn btn-outline-primary" onclick="sortProxies('connectivity', 'asc')">连通率低→高</button>
                            <button type="button" class="btn btn-outline-primary" onclick="sortProxies('avgDelay', 'asc')">平均延迟低→高</button>
                            <button type="button" class="btn btn-outline-primary" onclick="sortProxies('avgDelay', 'desc')">平均延迟高→低</button>
                            <button type="button" class="btn btn-outline-primary" onclick="sortProxies('name', 'asc')">名称排序</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 代理节点统计信息 -->
        <div id="proxyStatsContainer" class="row mb-4">
            <!-- 统计信息将在这里动态生成 -->
            <div class="col-12 text-center py-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">加载中...</span>
                </div>
                <p class="mt-2">加载代理节点统计信息...</p>
            </div>
        </div>

        <!-- 代理节点图表容器 -->
        <div id="proxyChartsContainer">
            <!-- 图表将在这里动态生成 -->
            <div class="text-center py-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">加载中...</span>
                </div>
                <p class="mt-2">加载代理节点图表...</p>
            </div>
        </div>

        <script th:inline="javascript">
            // 获取代理组名称
            const groupName = /*[[${config.groupName}]]*/ 'Proxy';
            let chartData;
            let charts = {};
            let currentDays = 7;
            let proxyStats = []; // 存储代理节点统计信息
            let currentSortField = 'connectivity'; // 默认排序字段
            let currentSortOrder = 'desc'; // 默认排序顺序
            
            // 页面加载完成后初始化图表
            document.addEventListener('DOMContentLoaded', function() {
                loadChartData(7); // 默认加载7天数据
            });
            
            // 加载图表数据
            function loadChartData(days) {
                currentDays = days;
                const url = `/proxy-monitor/api/history-data/${encodeURIComponent(groupName)}?days=${days}`;
                
                // 显示加载中状态
                document.getElementById('proxyStatsContainer').innerHTML = `
                    <div class="col-12 text-center py-5">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">加载中...</span>
                        </div>
                        <p class="mt-2">加载代理节点统计信息...</p>
                    </div>
                `;
                
                document.getElementById('proxyChartsContainer').innerHTML = `
                    <div class="text-center py-5">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">加载中...</span>
                        </div>
                        <p class="mt-2">加载代理节点图表...</p>
                    </div>
                `;
                
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        chartData = data;
                        processProxyData(data);
                        sortProxies(currentSortField, currentSortOrder);
                    })
                    .catch(error => {
                        console.error('获取延迟历史数据失败:', error);
                        alert('获取延迟历史数据失败: ' + error.message);
                    });
            }

            // 处理代理数据，计算统计信息
            function processProxyData(data) {
                proxyStats = [];
                const proxyNames = Object.keys(data.proxyDelays);
                
                // 处理时间数据，确保数据点均匀分布
                processTimeData(data);
                
                for (const proxyName of proxyNames) {
                    const delayValues = data.proxyDelays[proxyName];
                    const stats = calculateStats(delayValues);
                    
                    proxyStats.push({
                        name: proxyName,
                        delayValues: delayValues,
                        connectivityRate: stats.connectivityRate,
                        maxDelay: stats.maxDelay,
                        minDelay: stats.minDelay,
                        avgDelay: stats.avgDelay === 'N/A' ? 9999 : stats.avgDelay, // 用于排序
                        displayAvgDelay: stats.avgDelay
                    });
                }
            }

            // 处理时间数据，确保数据点均匀分布
            function processTimeData(data) {
                if (!data.timeLabels || data.timeLabels.length === 0) return;
                
                // 将时间字符串转换为Date对象
                const timeObjects = data.timeLabels.map(time => new Date(time));
                
                // 按时间排序
                timeObjects.sort((a, b) => a - b);
                
                // 获取最早和最晚的时间
                const earliestTime = timeObjects[0];
                const latestTime = timeObjects[timeObjects.length - 1];
                
                // 计算总时间跨度（毫秒）
                const timeSpan = latestTime - earliestTime;
                
                // 如果数据点过多，进行采样
                const maxDataPoints = 24; // 最大数据点数量
                if (timeObjects.length > maxDataPoints) {
                    // 计算采样间隔
                    const samplingInterval = Math.floor(timeObjects.length / maxDataPoints);
                    
                    // 创建新的时间标签和数据点
                    const newTimeLabels = [];
                    const newProxyDelays = {};
                    
                    // 初始化新的代理延迟数据结构
                    for (const proxyName in data.proxyDelays) {
                        newProxyDelays[proxyName] = [];
                    }
                    
                    // 采样数据点
                    for (let i = 0; i < timeObjects.length; i += samplingInterval) {
                        newTimeLabels.push(data.timeLabels[i]);
                        
                        for (const proxyName in data.proxyDelays) {
                            newProxyDelays[proxyName].push(data.proxyDelays[proxyName][i]);
                        }
                    }
                    
                    // 确保包含最后一个数据点
                    const lastIndex = timeObjects.length - 1;
                    if ((lastIndex % samplingInterval) !== 0) {
                        newTimeLabels.push(data.timeLabels[lastIndex]);
                        
                        for (const proxyName in data.proxyDelays) {
                            newProxyDelays[proxyName].push(data.proxyDelays[proxyName][lastIndex]);
                        }
                    }
                    
                    // 更新数据
                    data.timeLabels = newTimeLabels;
                    data.proxyDelays = newProxyDelays;
                }
            }
            
            // 排序代理节点
            function sortProxies(field, order) {
                currentSortField = field;
                currentSortOrder = order;
                
                // 高亮当前选中的排序按钮
                document.querySelectorAll('.btn-group button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`.btn-group button[onclick="sortProxies('${field}', '${order}')"]`).classList.add('active');
                
                if (!proxyStats || proxyStats.length === 0) return;
                
                proxyStats.sort((a, b) => {
                    let comparison = 0;
                    
                    if (field === 'connectivity') {
                        comparison = a.connectivityRate - b.connectivityRate;
                    } else if (field === 'avgDelay') {
                        comparison = a.avgDelay - b.avgDelay;
                    } else if (field === 'name') {
                        comparison = a.name.localeCompare(b.name);
                    }
                    
                    return order === 'asc' ? comparison : -comparison;
                });
                
                // 更新UI
                createProxyStats();
                createProxyCharts();
            }
            
            // 创建代理节点统计信息
            function createProxyStats() {
                const statsContainer = document.getElementById('proxyStatsContainer');
                statsContainer.innerHTML = '';
                
                if (proxyStats.length === 0) {
                    statsContainer.innerHTML = `
                        <div class="col-12">
                            <div class="alert alert-info">
                                没有找到代理节点数据
                            </div>
                        </div>
                    `;
                    return;
                }
                
                // 创建统计信息卡片
                for (const proxy of proxyStats) {
                    const statsCard = document.createElement('div');
                    statsCard.className = 'col-md-3 mb-4';
                    statsCard.innerHTML = `
                        <div class="card h-100 ${proxy.connectivityRate < 80 ? 'border-danger' : 'border-success'}">
                            <div class="card-header ${proxy.connectivityRate < 80 ? 'bg-danger text-white' : 'bg-success text-white'}">
                                <h5 class="card-title mb-0">${proxy.name}</h5>
                            </div>
                            <div class="card-body">
                                <ul class="list-group list-group-flush">
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        连通率
                                        <span class="badge ${proxy.connectivityRate < 80 ? 'bg-danger' : 'bg-success'} rounded-pill">${proxy.connectivityRate}%</span>
                                    </li>
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        最大延迟
                                        <span class="badge bg-primary rounded-pill">${proxy.maxDelay}ms</span>
                                    </li>
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        最小延迟
                                        <span class="badge bg-primary rounded-pill">${proxy.minDelay}ms</span>
                                    </li>
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        平均延迟
                                        <span class="badge bg-primary rounded-pill">${proxy.displayAvgDelay}ms</span>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    `;
                    
                    statsContainer.appendChild(statsCard);
                }
            }
            
            // 计算统计信息
            function calculateStats(delayValues) {
                // 过滤掉未连通的值（-1）
                const connectedValues = delayValues.filter(v => v >= 0);
                
                // 计算连通率
                const connectivityRate = Math.round((connectedValues.length / delayValues.length) * 100);
                
                // 如果没有连通的值，返回默认统计信息
                if (connectedValues.length === 0) {
                    return {
                        connectivityRate: 0,
                        maxDelay: 'N/A',
                        minDelay: 'N/A',
                        avgDelay: 'N/A'
                    };
                }
                
                // 计算最大、最小和平均延迟
                const maxDelay = Math.max(...connectedValues);
                const minDelay = Math.min(...connectedValues);
                const avgDelay = Math.round(connectedValues.reduce((a, b) => a + b, 0) / connectedValues.length);
                
                return {
                    connectivityRate,
                    maxDelay,
                    minDelay,
                    avgDelay
                };
            }
            
            // 创建代理节点图表
            function createProxyCharts() {
                const chartsContainer = document.getElementById('proxyChartsContainer');
                chartsContainer.innerHTML = '';
                
                if (proxyStats.length === 0) {
                    chartsContainer.innerHTML = `
                        <div class="col-12">
                            <div class="alert alert-info">
                                没有找到代理节点数据
                            </div>
                        </div>
                    `;
                    return;
                }
                
                // 清空现有图表
                for (const chartId in charts) {
                    if (charts[chartId]) {
                        try {
                            charts[chartId].dispose();
                        } catch (e) {
                            console.error(`销毁图表 ${chartId} 失败:`, e);
                        }
                        charts[chartId] = null;
                    }
                }
                charts = {};
                
                // 准备时间标签
                const timeLabels = chartData.timeLabels.map(time => {
                    try {
                        return new Date(time).getTime(); // 转换为时间戳
                    } catch (e) {
                        console.error(`无效的时间格式: ${time}`, e);
                        return null;
                    }
                }).filter(time => time !== null);
                
                // 为每个代理节点创建图表
                for (let i = 0; i < proxyStats.length; i++) {
                    const proxy = proxyStats[i];
                    
                    const chartRow = document.createElement('div');
                    chartRow.className = 'row mb-4';
                    
                    const chartCol = document.createElement('div');
                    chartCol.className = 'col-12';
                    
                    const chartCard = document.createElement('div');
                    chartCard.className = 'card';
                    
                    const chartCardBody = document.createElement('div');
                    chartCardBody.className = 'card-body';
                    
                    const chartTitle = document.createElement('h5');
                    chartTitle.className = 'card-title';
                    chartTitle.textContent = `${proxy.name} 延迟历史 | 连通率: ${proxy.connectivityRate}% | 平均延迟: ${proxy.displayAvgDelay === 'N/A' ? proxy.displayAvgDelay : proxy.displayAvgDelay + 'ms'}`;
                    
                    const chartContainer = document.createElement('div');
                    chartContainer.className = 'chart-container';
                    chartContainer.style.height = '300px';
                    chartContainer.style.width = '100%';
                    
                    // 使用索引号作为ID的一部分，避免特殊字符问题
                    const chartId = `chart-${i}-${encodeURIComponent(proxy.name)}`;
                    chartContainer.id = chartId;
                    
                    chartCardBody.appendChild(chartTitle);
                    chartCardBody.appendChild(chartContainer);
                    chartCard.appendChild(chartCardBody);
                    chartCol.appendChild(chartCard);
                    chartRow.appendChild(chartCol);
                    
                    chartsContainer.appendChild(chartRow);
                    
                    // 记录调试信息
                    console.log(`准备创建图表: ${chartId} 代理名称: ${proxy.name}`);
                    
                    // 等待DOM更新后再创建图表
                    setTimeout(() => {
                        try {
                            // 创建图表
                            charts[chartId] = createEChart(chartId, timeLabels, proxy.delayValues, proxy.name);
                            if (!charts[chartId]) {
                                console.error(`图表 ${chartId} (${proxy.name}) 创建失败，返回了null`);
                            } else {
                                console.log(`图表 ${chartId} (${proxy.name}) 创建成功`);
                            }
                        } catch (error) {
                            console.error(`创建图表 ${chartId} (${proxy.name}) 时发生错误:`, error);
                        }
                    }, 100);
                }
            }
            
            // 创建单个ECharts图表
            function createEChart(chartId, timeLabels, delayValues, proxyName) {
                console.log(`开始创建图表: ${chartId}`);
                
                // 确保容器存在且有尺寸
                const container = document.getElementById(chartId);
                if (!container) {
                    console.error(`图表容器 ${chartId} 不存在`);
                    return null;
                }
                
                // 初始化图表前确保容器可见
                container.style.height = '300px';
                container.style.width = '100%';
                
                try {
                    console.log(`初始化图表: ${chartId}, 容器尺寸: ${container.clientWidth}x${container.clientHeight}`);
                    const chart = echarts.init(container);
                    
                    // 准备数据并过滤无效值
                    const data = [];
                    for (let i = 0; i < timeLabels.length; i++) {
                        // 确保时间戳是有效的数字
                        const time = Number(timeLabels[i]);
                        if (isNaN(time)) {
                            console.warn(`跳过无效时间戳: ${timeLabels[i]}`);
                            continue;
                        }
                        data.push([time, delayValues[i]]);
                    }
                    
                    console.log(`图表 ${chartId} 数据点数量: ${data.length}`);
                    
                    // 如果数据为空，显示无数据提示
                    if (data.length === 0) {
                        console.warn(`图表 ${chartId} 没有有效数据点`);
                        container.innerHTML = '<div class="alert alert-warning">没有有效的数据点</div>';
                        return null;
                    }
                    
                    // 图表配置
                    const option = {
                        tooltip: {
                            trigger: 'axis',
                            formatter: function(params) {
                                const time = new Date(params[0].value[0]).toLocaleString();
                                const value = params[0].value[1];
                                if (value < 0) {
                                    return `${time}<br/>状态: 未连通`;
                                } else {
                                    return `${time}<br/>延迟: ${value}ms`;
                                }
                            },
                            axisPointer: {
                                animation: false
                            }
                        },
                        grid: {
                            left: '3%',
                            right: '4%',
                            bottom: '3%',
                            containLabel: true
                        },
                        xAxis: {
                            type: 'time',
                            splitLine: {
                                show: false
                            },
                            axisLabel: {
                                formatter: function(value) {
                                    const date = new Date(value);
                                    if (currentDays <= 1) {
                                        return date.getHours() + ':' + String(date.getMinutes()).padStart(2, '0');
                                    } else {
                                        return (date.getMonth() + 1) + '-' + date.getDate() + ' ' + date.getHours() + ':' + String(date.getMinutes()).padStart(2, '0');
                                    }
                                }
                            }
                        },
                        yAxis: {
                            type: 'value',
                            name: '延迟 (ms)',
                            axisLabel: {
                                formatter: function(value) {
                                    if (value < 0) return '未连通';
                                    return value;
                                }
                            },
                            splitLine: {
                                show: true
                            }
                        },
                        series: [{
                            name: `${proxyName} 延迟`,
                            type: 'line',
                            showSymbol: true,
                            data: data,
                            lineStyle: {
                                width: 2
                            },
                            itemStyle: {
                                color: getRandomColor()
                            },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [{
                                        offset: 0,
                                        color: getRandomColor().replace('1)', '0.5)')
                                    }, {
                                        offset: 1,
                                        color: getRandomColor().replace('1)', '0.05)')
                                    }]
                                }
                            },
                            markLine: {
                                silent: true,
                                data: [{
                                    yAxis: 0,
                                    lineStyle: {
                                        color: '#999',
                                        type: 'dashed'
                                    },
                                    label: {
                                        show: false
                                    }
                                }]
                            }
                        }]
                    };
                    
                    // 设置图表配置
                    console.log(`设置图表 ${chartId} 配置`);
                    chart.setOption(option);
                    console.log(`图表 ${chartId} 配置已设置`);
                    
                    // 响应式调整
                    window.addEventListener('resize', function() {
                        if (chart && !chart.isDisposed()) {
                            chart.resize();
                        }
                    });
                    
                    return chart;
                } catch (error) {
                    console.error(`创建图表 ${chartId} 失败:`, error);
                    container.innerHTML = `<div class="alert alert-danger">图表加载失败: ${error.message}</div>`;
                    return null;
                }
            }
            
            // 获取随机颜色
            function getRandomColor() {
                const colors = [
                    'rgba(255, 99, 132, 1)',
                    'rgba(54, 162, 235, 1)',
                    'rgba(255, 206, 86, 1)',
                    'rgba(75, 192, 192, 1)',
                    'rgba(153, 102, 255, 1)',
                    'rgba(255, 159, 64, 1)',
                    'rgba(199, 199, 199, 1)',
                    'rgba(83, 102, 255, 1)',
                    'rgba(40, 159, 64, 1)',
                    'rgba(210, 199, 199, 1)'
                ];
                
                return colors[Math.floor(Math.random() * colors.length)];
            }
        </script>
    </div>
</body>
</html> 